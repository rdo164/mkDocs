{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"011.la-l%C3%ADnea-de-%C3%B3rdenes/","title":"La l\u00ednea de \u00f3rdenes","text":"<p>Mientras que en un entorno gr\u00e1fico lo que ves es pr\u00e1cticamente lo que hay, en la l\u00ednea de \u00f3rdenes las posibilidades de configurar y de llevar a cabo \u00f3rdenes es pr\u00e1cticamente infinita, adem\u00e1s de extensible. En un entorno de desarrollo es mejor aprender a manejarla bien, ya que nos permitir\u00e1 acceder a todo tipo de scripts y de opciones de los mismos. Aunque es posible que se pueda trabajar desde un entorno integrado, lo mejor es, para una bulla, poder echar mano de la l\u00ednea de \u00f3rdenes.</p>"},{"location":"011.la-l%C3%ADnea-de-%C3%B3rdenes/#que-linea-de-ordenes","title":"Qu\u00e9 l\u00ednea de \u00f3rdenes","text":"<p>Casi todas las distribuciones Linux modernas, e incluso Windows en su subsistema Ubuntu y MacOS en su l\u00ednea de \u00f3rdenes, trae <code>bash</code>. Es suficientemente buena para la mayor\u00eda de sus objetivos. Sin embargo, otros dos entornos, <code>zsh</code> y <code>fish</code>, son bastante m\u00e1s configurables y ofrecen una serie de facilidades para el programador que los hacen bastante interesantes.</p> <p>Para instalarlos, sigue el procedimiento habitual en tu sistema operativo: <code>apt</code>, <code>yum</code>, <code>brew</code> o similar.</p>"},{"location":"011.la-l%C3%ADnea-de-%C3%B3rdenes/#temas-en-la-linea-de-ordenes","title":"Temas en la l\u00ednea de \u00f3rdenes.","text":"<p>Todos los shells mencionados anteriormente son temables, es decir, los puedes configurar para que la l\u00ednea de \u00f3rdenes presente informaci\u00f3n relativa a la rama del repositorio de c\u00f3digo en la que est\u00e1s, versi\u00f3n del int\u00e9rprete o compilador con el que est\u00e1s trabajando, aparte de si hay cambios en el repositorio o el directorio en el que est\u00e1s.</p> <p>Aunque estos temas se pueden configurar a mano a base de cambiar el <code>PROMPT</code>, es mejor usar aplicaciones que te permitan elegir temas que tengan ya una combinaci\u00f3n de colores, caracteres y l\u00edneas de estado predeterminados. Bash-it es uno de ellos, pero tambi\u00e9n Oh-My-Zsh para <code>zsh</code> te proveen esta facilidad.</p> <p></p> <p>Por ejemplo, en la l\u00ednea de \u00f3rdenes anterior se muestra la rama del repositorio en la que se est\u00e1 (<code>master</code>), as\u00ed como, con la cruz amarilla, el hecho de que hay cambios en el repositorio que no se han registrado. Esto nos ayuda a conocer de un vistazo el estado del mismo, y toda la informaci\u00f3n que presentan, como el directorio, a navegar m\u00e1s f\u00e1cilmente mientras estamos desarrollando. </p>"},{"location":"011.la-l%C3%ADnea-de-%C3%B3rdenes/#moviendose-por-la-linea-de-ordenes","title":"Movi\u00e9ndose por la l\u00ednea de \u00f3rdenes.","text":""},{"location":"011.la-l%C3%ADnea-de-%C3%B3rdenes/#algunas-ordenes-utiles","title":"Algunas \u00f3rdenes \u00fatiles.","text":""},{"location":"03.datos/","title":"Tipos de datos b\u00e1sicos y c\u00f3mo trabajar con ellos","text":"<p>Los tipos simples, para simplificar, son de dos tipos solamente: o n\u00fameros o palabras. Nada es simple, y todo se puede complicar eventualmente (y lo har\u00e1),  pero por lo pronto qued\u00e9monos ah\u00ed.</p> <p>Arrancamos <code>gore</code> u otro REPL desde nuestra l\u00ednea de \u00f3rdenes, y vamos a ver c\u00f3mo trabajar con estos datos. \u00c1brelo y  empieza a teclear n\u00fameros y palabras por separado</p> <pre><code>gore&gt; 3\ngore&gt; \"cosas\"\n</code></pre> <p>Las palabras llevar\u00e1n comillas alrededor. Incluso aunque se trate de una sola letra. El int\u00e9rprete se acuerda de lo \u00faltimo que has tecleado, y puedes acceder a \u00e9l usando \u2191. Repitiendo y editando podemos pasar el d\u00eda, as\u00ed que vamos a empezar a hacer algo con estos n\u00fameros. Por ejemplo...</p>"},{"location":"03.datos/#un-poco-de-aritmetica-basica","title":"un poco de aritm\u00e9tica b\u00e1sica","text":"<p>Los ordenadores, en realidad, son calculadoras con complicaciones. Lo m\u00e1s b\u00e1sico que se puede hacer es operaciones aritm\u00e9ticas. Go no tiene nada inesperado en este \u00e1rea. Suma, resta, multiplicaci\u00f3n y divisi\u00f3n</p> <pre><code>gore&gt; 3*8+5.2/8\n</code></pre> <p>que debe dar 24.65, un n\u00famero real o <code>float</code> en el argot del lenguaje.</p> <p>Adicionalmente, el operador <code>%</code> te permite hacer divisi\u00f3n entera</p> <pre><code>gore&gt; 17 % 3\n3\n</code></pre> <p>La mayor\u00eda de los lenguajes con un int\u00e9rprete tal como <code>gore</code> se comportan de una forma similar, aunque algunos pueden tener otros operadores o llamar a los operadores no est\u00e1ndar de otra forma. Por ejemplo, si abres la consola de desarrollo en tu navegador (con may\u00fasculas-control-k en Firefox, por ejemplo), tendr\u00e1s el mismo resultado, aunque estaremos trabajando en JavaScript.</p> <p></p> <p>Y aunque inicialmente hayamos metido a todos los n\u00fameros en el mismo saco, no todos son iguales. Los enteros o naturales y los n\u00fameros reales (los que tienen coma decimal) se comportar\u00e1n de forma diferente, aunque no habr\u00e1 que preocuparse (demasiado) por ello ahora mismo. </p> <p>Los n\u00fameros que Go entiende son los n\u00fameros ar\u00e1bigos, vamos,  los de toda la vida. Si usamos n\u00fameros romanos como \u2164 no los entender\u00e1 como tal,  sino como un car\u00e1cter y nos dar\u00e1 un error de variable no definida. No en todos los lenguajes es as\u00ed. Perl 6 trabaja de forma nativa con este tipo de n\u00fameros, y <code>\u2164+5</code> resultar\u00e1 en el n\u00famero 10, y <code>5**\u2164</code> en 3125. Los lenguajes de programaci\u00f3n, poco a poco, van empezando a usar el potencial completo de Unicode, pero algunos lenguajes, como Python, JavaScript o Go todav\u00eda no han llegado a hacerlo. </p> <p>Sin embargo, todos estos lenguajes suelen incluir el operador m\u00f3dulo y llamarlo <code>%</code>, este operador devuelve el resto de dividir el numerador, a la izquierda del mismo, del denominador, a la derecha:</p> <pre><code>gore&gt; 17 % 11\n6\n</code></pre> <p>Como buen lenguaje de programaci\u00f3n, tambi\u00e9n podemos</p>"},{"location":"03.datos/#trabajar-con-cualquier-tipo-de-caracter","title":"Trabajar con cualquier tipo de car\u00e1cter","text":"<p>Pero vamos a dar un paso hacia atr\u00e1s, o hacia un lado, para reconocer que existen letras m\u00e1s all\u00e1 de nuestro alfabeto latino. Empezando por los emojis, tales como este, \u2323, y terminando con los caracteres de alfabetos vivos o muertos como este \ua861. Un lenguaje de programaci\u00f3n moderno, y un ordenador moderno, debe ser capaz de trabajar con todos ellos.</p> <pre><code>\"\u00feor el poderoso \u270c\"\n</code></pre> <p>Como hemos visto m\u00e1s arriba, las cadenas o strings est\u00e1n rodeadas por comillas, dobles <code>\"</code> o backticks <code>`</code>. Las primeras  no pueden contener saltos de l\u00ednea y permiten la utilizaci\u00f3n de secuencias de escape, es decir, caracteres que permiten escribir cosas que no son exactamente caracteres, como retornos de l\u00ednea, tabuladores o incluso colores. </p> <p>Hemos elegido \u00fe como car\u00e1cter raro porque es uno de los pocos de este tipo que se pueden teclear f\u00e1cilmente desde el teclado castellano. \u00fe sale con AltGr + p. Otros caracteres son \u00df, que sale con AltGr + s u \u00f8, que se obtiene con AltGr + o.</p> <p>Cualquier tipo de cadena est\u00e1 compuesta por un n\u00famero de caracteres determinado, que se halla con <code>len</code>: <pre><code>gore&gt; var cadena = \"micadena\"\ngore&gt; len(cadena)\n8\n</code></pre> Las cadenas est\u00e1n hechas de bytes individuales. Normalmente, cada caracter ocupa un solo <code>byte</code> aunque puede darse el caso que caracteres de otros idiomas por ejemplo, el ruso, ocupen m\u00e1s de un <code>byte</code>.</p> <p>Las cadenas est\u00e1n divididas en los caracteres que lo componen, y podemos acceder a ellos indicando su \u00edndice, que comienza por 0: <code>\"\u00feor el poderoso \u270c\"[16]</code> devolver\u00e1 el valor en <code>byte</code> de \u270c.  Tambi\u00e9n podemos acceder a grupos de caracteres, usando el rango <code>x:y</code>. <code>cadena[0:3]</code> nos devolver\u00e1 los 4 primeros caracteres de la cadena. Otra opci\u00f3n v\u00e1lida ser\u00eda <code>cadena[:3]</code>. Como al acceder a un caracter de una cadena obtenemos su valor en <code>byte</code> y este es un valor num\u00e9rico, podemos aplicarle los operadores aritm\u00e9ticos. </p> <p>Para la concatenaci\u00f3n de cadenas, utilizaremos el caracter <code>+</code>:</p> <pre><code>gore&gt;&gt; \"Nos vamos \"+\"a la feria\"\n\"Nos vamos a la feria\"\n</code></pre> <p>Ojo: a partir de aqu\u00ed es de Python</p> <p>\u00bfY qu\u00e9 ocurre cuando tratamos de mezclarlas con los n\u00fameros? Pues que  resulta en un error. Aparte de tener tipado pato, Python usa tambi\u00e9n comprobaci\u00f3n din\u00e1mica de tipos para saber si se puede aplicar o no una  operaci\u00f3n a sus operandos. En este caso no encuentra ninguna forma sensata de sumar una cadena a un n\u00famero, as\u00ed que simplemente expresa su disconformidad con el asunto, diciendo que se trata de una operaci\u00f3n inv\u00e1lida.</p>"},{"location":"03.datos/#hablemos-de-los-problemas-de-entendimiento","title":"Hablemos de los problemas de entendimiento.","text":"<p>En el caso anterior, el int\u00e9rprete nos ha dicho: <code>TypeError: must be str, not int</code>. Pero es leer la palabra error y uno empieza a sentirse culpable. Es culpa m\u00eda, todo lo hago mal, voy a empezar de nuevo hasta que lo consiga.</p> <p>Pero no hay por qu\u00e9 tom\u00e1rselo as\u00ed. Error es simplemente la forma en la que los ordenadores nos dicen \"No te he entendido bien\". Los ordenadores, y los int\u00e9rpretes de lenguajes, son muy literales y todo lo interpretan tal y como se ha tecleado. Miran, y si no te entienden te lo dicen. Pero tambi\u00e9n te dan a entender que es un problema de expectativas. Esperaban una cosa, y ha sido otra: <code>must be str, not int</code>. Debe ser un <code>str</code>, no un <code>int</code>. Si fueran capaces de saber de qu\u00e9 cadena se trata, ellos mismos lo har\u00edan. De hecho, algunos otros lenguajes se comportar\u00e1n de forma diferente. JavaScript, por ejemplo, dir\u00e1 que <code>\"3.4\"+7</code> es, naturalmente, <code>3.47</code> haciendo una conversi\u00f3n impl\u00edcita de un n\u00famero a una cadena. Otro lenguaje, R, te dir\u00e1: <code>Error in \"3.4\" + 7 : argumento no-num\u00e9rico para operador binario</code>. No le gusta la cadena y no tiene reparos en decirlo, porque R es un lenguaje estad\u00edstico, y por tanto (casi) matem\u00e1tico. Perl, sin embargo, llevar\u00e1 el tipado pato hasta las \u00faltimas consecuencias, dando como resultado 10.4. </p> <p>Lo que viene a querer decir que lenguajes diferentes van a entender esa expresi\u00f3n, forzosamente ambigua, de forma diferente. Pero si no la entienden, te van a dar alguna pista de por qu\u00e9 no lo han hecho.</p> <p>Volvamos a Python: <code>TypeError: must be str, not int</code> te dice que hay un problema con el tipo de uno de los operandos, que debe ser una cadena (<code>str</code>), no un entero. Como s\u00f3lo hay un entero, el n\u00famero 7, eso quiere decir que ah\u00ed es donde est\u00e1 el error, al menos seg\u00fan Python. De hecho, si lo hacemos al rev\u00e9s, <code>7+\"3.4\"</code>, Python nos dir\u00e1:</p> <p><pre><code>TypeError: unsupported operand type(s) for +: 'int' and 'str'\n</code></pre> que es algo m\u00e1s informativo. Ya no te est\u00e1 diciendo que el entero es un error, sino que alguno de los dos est\u00e1 equivocado. En las l\u00edneas anteriores, adem\u00e1s, te indica d\u00f3nde ha ocurrido, aunque <code>File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;</code>no sea demasiado amigable. </p> <p>En todo caso, estos mensajes te ayudan a entender d\u00f3nde ha producido el malentendido y de qu\u00e9 se trata. Aunque est\u00e9n en ingl\u00e9s (en la mayor\u00eda de los casos), conviene leerlos tranquilamente y comprender qu\u00e9 es lo que dicen, porque te da la pista de por qu\u00e9 el ordenador no ha sido capaz de entender lo que se le quer\u00eda decir. En este caso, porque Python no sabe como sumar dos cosas que tienen un tipo diferente. Simplemente, a la siguiente, se le suministran cosas a los dos lados del signo + que sean compatibles y listos.</p> <p>Y si todo falla, siempre puedes buscarlo en Internet. Eliminando lo que sea espec\u00edfico de tu c\u00f3digo, como nombres de variable y dem\u00e1s, puedes buscar el resto y llegar\u00e1, en la mayor parte de los casos, a StackOverflow donde ver\u00e1s contextos similares y una soluci\u00f3n al problema. En este caso, te viene a decir que hay que hacer una conversi\u00f3n expl\u00edcita: <code>7+float(\"3.4\")</code>, lo que est\u00e1 totalmente de acuerdo con el zen de Python: </p> <pre><code>&gt;Expl\u00edcito antes que impl\u00edcito\n</code></pre> <p>Y, por supuesto, toda esta secci\u00f3n se corresponde al de</p> <pre><code>&gt;Los errores no deben suceder en silencio\n</code></pre> <p>Como conclusi\u00f3n a esta secci\u00f3n: si el ordenador no te entiende y te lo dice cort\u00e9smente, lee, comprende, trata de adaptarte a lo que requiere, pero si todo falla, Google es tu amigo.</p>"},{"location":"03.datos/#concluyendo","title":"Concluyendo","text":"<p>No es malo equivocarse. Sucede en las mejores familias, incluso en las operaciones m\u00e1s b\u00e1sicas. Para las cuales puedes usar Go como si fuera una calculadora un poco m\u00e1s complicada y que usara, adem\u00e1s, cadenas de caracteres. Vale, una calculadora complicada y rara. </p>"},{"location":"1_logica/04.logica/","title":"L\u00f3gica","text":"<p>Estamos tratando con ordenadores. La computaci\u00f3n se basa en bits. Los bits solo pueden tener dos valores: 0 o 1. Verdad o mentira. Este principio se utiliza para tomar decisiones como, por ejemplo, decidir si un n\u00famero es mayor que otro. Ya nos preocuparemos de hacer una reedici\u00f3n de este libro cuando la computaci\u00f3n cu\u00e1ntica introduzca nuevos paradigmas y sea asequible mortales como nosotros. Pero, vamos a centrarnos...</p> <p>El tipo asociado a la verdad o mentira, se llama booleano en honor a George Boole y su famosa (y odiada por muchos) \"\u00e1lgebra de Boole\".</p> <p>En muchos lenguajes, podemos utilizar distintos tipos de datos para representar booleanos, En C y C++ podemos utilizar los enteros 0 y 1 como booleanos, aunque el propio C++ ya implemente estos tipos de forma nativa. En Python, cualquier cosa que pueda parecer un booleano lo es, como un entero o un conjunto. En Go eso no es as\u00ed, siendo obligatorio el uso de variables de tipo booleano.</p>"},{"location":"1_logica/04.logica/#operaciones-logicas","title":"Operaciones l\u00f3gicas","text":"<p>Las operaciones l\u00f3gicas de las que disponemos en Go son las ya cl\u00e1sicas de otros lenguajes de programaci\u00f3n. Al aplicar estas operaciones, obtendremos otra salida booleana.</p> <p>As\u00ed pues, el operando negaci\u00f3n, <code>!</code>, nos devolver\u00e1 el valor contrario al que tengamos. De forma que <code>!true</code> tiene como valor <code>false</code> y <code>!true</code> devolver\u00e1 <code>true</code>. Para utilizarlo, solo necesitas situarlo delante de lo que quieres negar. Para utilizarlo, solo se necesita un valor y, por tanto, es un operador unario. </p> <p>El operador <code>&amp;&amp;</code> corresponde con el operador l\u00f3gico \"and\". Si algunos de los dos elementos que forman parte de la operaci\u00f3n tiene como valor <code>false</code>, el resultado de la operaci\u00f3n es <code>false</code>. Para que nos entendamos:</p> <pre><code>gore&gt; true &amp;&amp; true\ntrue\ngore&gt; true &amp;&amp; false\nfalse\ngore&gt; false &amp;&amp; true\nfalse\ngore&gt; false &amp;&amp; false\nfalse\n</code></pre> <p>El \u00faltimo operador del que disponemos es <code>||</code>, que corresponde al \"or\" l\u00f3gico. Con que uno de los dos operados sea verdadero, el resultado tambi\u00e9n lo es:</p> <pre><code>gore&gt; true &amp;&amp; true\ntrue\ngore&gt; true &amp;&amp; false\ntrue\ngore&gt; false &amp;&amp; true\ntrue\ngore&gt; false &amp;&amp; false\nfalse\n</code></pre> <p>Como ya se ha mencionado arriba, si intentas aplicar los operadores l\u00f3gicos a elementos cuyo tipo no sea booleano, obtendremos un error:</p> <pre><code>gore&gt; 1&amp;&amp;1\n# command-line-arguments\n/tmp/315015652/gore_session.go:16: invalid operation: 1 &amp;&amp; 1 (operator &amp;&amp; not defined on untyped number)\nerror: exit status 2\nexit status 2\ngore&gt; int(1)&amp;&amp;int(1)\n# command-line-arguments\n/tmp/315015652/gore_session.go:16: invalid operation: int(1) &amp;&amp; int(1) (operator &amp;&amp; not defined on int)\nerror: exit status 2\nexit status 2\ngore&gt; \"falso\"||\"verdad\"\n# command-line-arguments\n/tmp/315015652/gore_session.go:16: invalid operation: \"falso\" || \"verdad\" (operator || not defined on string)\nerror: exit status 2\nexit status 2\n</code></pre> <p>Esto puede sernos bastante engorroso si venimos de, por ejemplo, Python. Pero tambi\u00e9n es una forma de ayudar al programador: solo se va a aplicar operaciones l\u00f3gicas a aquellos elementos a los que haya que aplic\u00e1rselo.</p> <p>Ejercicio: se dice que una f\u00f3rmula es \"satisfacible\" si es verdadera al  menos para una combinaci\u00f3n de valores. Con una f\u00f3rmula de 3 variables, \u00bfcuantas combinaciones posibles de valores hay? Dise\u00f1a una f\u00f3rmula y pru\u00e9bala sistem\u00e1ticamente hasta que encuentres si es satisfacible o no. Alt\u00e9rala y convi\u00e9rtela en no-satisfacible, prob\u00e1ndola tambi\u00e9n sistem\u00e1ticamente.</p> <p>Estos operadores necesitan dos operandos y, por tanto, se llaman binarios. En la mayor\u00eda de lenguajes de programaci\u00f3n, o al menos en los m\u00e1s conocidos, se escriben de la misma forma.</p> <p>Hay otras operaciones como <code>\u2192</code>, que corresponde con la implicaci\u00f3n. Es decir, para <code>A \u2192 B</code>, si A, entonces B. Si A es cierto, entonces el resultado de <code>A \u2192 B</code> es B. Pero si es falso, el resultado estar\u00eda indeterminado, por lo que este operador es, en general, ternario, expresando dos posibles resultados dependiendo si el antecedente es cierto o falso. En Python lo expresar\u00edamos como:</p> <pre><code>\"Cierto\" if True else \"Falso\"\n\"Cierto\"\n</code></pre> <p>En Go no disponemos de operaciones ternarias en una l\u00ednea, pero podemos obtener el mismo resultado con el siguiente c\u00f3digo:</p> <pre><code>c := b\nif a &gt; b {\n    c = a\n}\n</code></pre>"},{"location":"1_logica/04.logica/#otras-operaciones-que-devuelven-valores-logicos","title":"Otras operaciones que devuelven valores l\u00f3gicos","text":"<p>Algunas operaciones, de las que ya vienen predefinidas en el lenguaje, tambi\u00e9n nos devuelven booleanos. El ejemplo m\u00e1s claro, la comparaci\u00f3n utilizando los operandos \"&lt;\" (menor que), \"&gt;\" (mayor que), \"&lt;=\" (menor o  igual que) o \"&gt;=\" (mayor o igual que):</p> <pre><code>gore&gt; 1 &lt; 2\ntrue\ngore&gt; -22 &gt; -555\ntrue\ngore&gt; -2 &gt;= -53.3\ntrue\ngore&gt; \"arbol\" &lt; \"brazo\"\ntrue\ngore&gt; \"a\" &lt; 21.2\n# command-line-arguments\n/tmp/315015652/gore_session.go:16: cannot convert \"a\" to type float64\n/tmp/315015652/gore_session.go:16: invalid operation: \"a\" &lt; 21.2 (mismatched types string and float64)\nerror: exit status 2\nexit status 2\n</code></pre> <p>El orden de los n\u00fameros es claro, mientras que las cadenas siguen el orden de la tabla Unicode. Es por ello que si comparamos, por ejemplo, con una <code>\u00f1</code>, empiezan a pasar cosas que pueden parecer \"raras\":</p> <pre><code>gore&gt; \"\u00f1\" &lt; \"z\"\nfalse\n</code></pre> <p>Pero, como ya se ha dicho, el orden en el caso de las cadenas de texto viene determinado por la tabla Unicode.</p> <p>De nuevo, solo podremos utilizar elementos del mismo tipo con estas operaciones.</p> <p>Tambi\u00e9n disponemos del operando \"\" (igualdad). Este operando se utiliza de igual forma en casi  todos los lenguajes, aunque algunos incluyen tambi\u00e9n el operando \"\"=\"\", como JavaScript, que diferencia entre igualdad abstracta e igualdad estricta y. \u00bfPor qu\u00e9 utilizar dos s\u00edmbolos de igual en vez de uno para representar el concepto de \"igualdad\"? El operando \"=\" se guarda para la asignaci\u00f3n de valores a variables, eso s\u00ed, una vez que han sido declaradas. Si no las declarado, tienes dos opciones: <code>var i int = 1</code> o <code>i:=1</code>. La segunda no estar\u00e1 disponible si no estamos dentro de una funci\u00f3n.</p> <p>En cuanto a la desigualdad, la podemos representar utilizando \"!=\".  Podr\u00edamos tambi\u00e9n negar la igualdad, es decir: <code>!a == b</code> en lugar de <code>a != b</code>, pero no es tan expresivo y ser\u00eda correcto computacionalmente, pero no sint\u00e1cticamente.</p> <p>Ejercicio: Usando s\u00f3lo los s\u00edmbolos de mayor y menor y operadores l\u00f3gicos (&amp;&amp; y ||), construir una expresi\u00f3n que sea equivalente a !=. Probar con diferentes valores que efectivamente \\ es as\u00ed.</p> <p>Ejercicio: probar, usando todos los casos posibles, las leyes de De Morgan. \u00bfCu\u00e1l ser\u00eda el modo Go de expresar una expresi\u00f3n de ese estilo?</p>"},{"location":"1_logica/04.logica/#precedencia","title":"Precedencia","text":"<p>Al igual que en las operaciones matem\u00e1ticas, la precedencia es muy importante en las operaciones l\u00f3gicas. Por ejemplo: <code>not 0 and 1</code>, \u00bfa qu\u00e9 es igual? \u00bfA (not 0) and 1? \u00bfO a not( 0 and 1))? En general, la precedencia estar\u00e1 marcada por los par\u00e9ntesis, luego la tendr\u00e1n los operadores unarios (como <code>-</code> precediendo a un n\u00famero) y finalmente los binarios, tambi\u00e9n por su orden. En los operadores l\u00f3gicos, la precedencia es <code>!</code> &gt; <code>&amp;&amp;</code> &gt; <code>||</code>, por lo que si quieres negar una expresi\u00f3n tendr\u00e1s que ponerlo entre par\u00e9ntesis.</p> <p>Esto conviene tenerlo en cuenta cuando queremos crear operadores combinados, como el siguiente:  En electr\u00f3nica, conviene expresar las operaciones l\u00f3gicas usando el m\u00ednimo n\u00famero de conectores posibles. Y resulta que <code>NAND</code>, donde <code>a NAND b == ! (a &amp;&amp; b)</code>, es suficiente para expresar absolutamente todos los operadores l\u00f3gicos unarios y binarios. En este caso el par\u00e9ntesis hace que se ejecute primero el <code>a &amp;&amp; b</code> antes que el <code>!</code>; la precedencia m\u00e1s alta del <code>!</code> obliga a que se haga de esta forma.</p> <p>Ejercicio: expresar and, or y not usando s\u00f3lo NAND y probar exhaustivamente, usando valores de true y false, que es as\u00ed.</p>"},{"location":"1_logica/04.logica/#un-poco-de-pensamiento-computacional","title":"Un poco de pensamiento computacional","text":"<p>Al final, los lenguajes de programaci\u00f3n son lenguajes que te permiten expresar y resolver problemas. El pensamiento computacional no deja de ser pensar utilizando ordenadores para resolver un problema a trav\u00e9s de un lenguaje de programaci\u00f3n, cuya base radica en: descomposici\u00f3n, reconocimiento de patrones y abstracci\u00f3n.</p> <p>La abstracci\u00f3n se basa, entre otras cosas, en saber elegir la estructura de datos adecuada para el problema con el que estamos trabajando. \u00bfSe trata de un n\u00famero? \u00bfUn conjunto de n\u00fameros? \u00bfUn conjunto de caracteres? En cualquier lenguaje de programaci\u00f3n, la estructura de datos elegida determina qu\u00e9 se puede hacer, eficientemente o posiblemente, con un dato determinado. Incluso el lenguaje de programaci\u00f3n a usar, porque no todos los lenguajes pueden trabajar con todos los datos f\u00e1cilmente. Por ejemplo, Python puede usar n\u00fameros complejos, con una parte real y otra imaginaria, como tipo de dato b\u00e1sico.</p> <p><pre><code>&gt;&gt;&gt; 3+0.1j\n3+0.1j\n(3+0.1j)\n&gt;&gt;&gt; _**2\n_**2\n(8.99+0.6000000000000001j)\n</code></pre> En Python, la parte imaginaria se representa, por alguna raz\u00f3n, por <code>j</code> en vez del convencional <code>i</code>, que es el que se usa en Ruby o en Perl6:</p> <pre><code> :002 &gt; (3+4i)*(5+0.1i)\n =&gt; (14.6+20.3i)\n</code></pre> <p>A priori, es complejo pensar en alg\u00fan problema \"del mundo real\" que use los n\u00fameros complejos. Pero las matem\u00e1ticas son tambi\u00e9n del mundo real, y problemas como \"\u00bfDiverge la sucesi\u00f3n (1+\u03c0i)\u207f?\" tendr\u00e1 que comenzar por una fase de abstracci\u00f3n en la que se decidir\u00e1 que la forma m\u00e1s eficiente de trabajar es usando estos n\u00fameros complejos. Trabajando en la l\u00ednea de \u00f3rdenes:</p> <pre><code>&gt;&gt;&gt;1 + 3.14j\n\n&gt;&gt;&gt; _ * (1 + 3.14j)\n_*(1+3.14j)\n(3.141592653589793+9.864600932271951j)\n&gt;&gt;&gt; _ * (1 + 3.14j)\n_*(1+3.14j)\n(-27.833254273744135 + 19.729201864543903j)\n&gt;&gt;&gt; _ * (1 + 3.14j)\n_*(1+3.14j)\n(-89.78294812841199-67.66721655501269j)\n&gt;&gt;&gt; _ * (1 + 3.14j)\n_*(1+3.14j)\n(122.69211185432786-349.5856736782264j)\n</code></pre> <p>Vemos que tiene toda la pinta de diverger, as\u00ed que la respuesta es que s\u00ed. El uso de n\u00fameros complejos ven\u00eda de forma natural en este caso, y el hecho de que Python lo tenga como estructura de datos b\u00e1sica es un hecho afortunado, por lo que es la elecci\u00f3n natural tambi\u00e9n. En otros lenguajes, como JavaScript, habr\u00eda sido algo m\u00e1s complicado, teniendo que usar vectores y definir una serie de funciones de multiplicaci\u00f3n de tales vectores al modo complejo.</p> <p>En Go puedes trabajar de la misma forma con los n\u00fameros complejos, pero utilizando <code>i</code> para designar a la parte imaginaria.</p> <p>La descomposici\u00f3n, por otro lado, trata de descomponer un problema monol\u00edtico en varios problemas m\u00e1s peque\u00f1os. Por ejemplo, descomponer un problema en una serie de operaciones b\u00e1sicas, todas ellas ya conocidas, que se puedan ejecutar en secuencia, en nuestro caso desde la l\u00ednea de \u00f3rdenes. Por ejemplo, veamos el problema de recrear todos los n\u00fameros del 1 al 5 usando exactamente 4 n\u00fameros 5, por separado o como cifras de un solo n\u00famero; tambi\u00e9n como decimales. La primera descomposici\u00f3n es natural: hacer cada n\u00famero por separado. Pero la segunda es tratar de conseguir partes de un n\u00famero usando operaciones con 5s. Cero, por ejemplo, es 5-5. Uno, 5/5. Esta no es la soluci\u00f3n a los dos primeros, pero s\u00ed para el tercero, 2 == 5/5 + 5/5. \u00bfY c\u00f3mo har\u00edamos 5? Teniendo en cuenta que cualquier cosa multiplicada por 0 es cero...</p> <p>Ejercicio: usa s\u00f3lo cuatro n\u00fameros 5 para reconstruir los n\u00fameros del 0 al 5. Si puedes, hazlo hasta el 10.</p> <p>El \u00faltimo mecanismo, el reconocimiento de patrones, se aleja m\u00e1s de lo puramente computacional, siendo simplemente una herramienta del pensamiento cr\u00edtico. Pero eso no quiere decir que no sea \u00fatil. Por ejemplo, muchas de las t\u00e9cnicas, o la mayor\u00eda, de las usadas en el ejercicio anterior, \u00bfse podr\u00edan usar con cualquier otro n\u00famero, es decir, sustituyendo el 5 por el 4 o por el 7?</p> <p>Ejercicio: \u00bfPara qu\u00e9 n\u00fameros se pueden usar m\u00e1s o menos los mismos patrones que para el 5? \u00bfFunciona con el 4? \u00bfFunciona con el 6? Espec\u00edficamente, \u00bfcon qu\u00e9 resultados hay que hacer peque\u00f1os cambios para que funcione?</p> <p>Como parte de la descomposici\u00f3n mencionada anteriormente est\u00e1 el hecho de que, eventualmente, toda la informaci\u00f3n que hay en un ordenador se reduce a puertas l\u00f3gicas que pueden tomar un valor 0 o 1, verdad o mentira. Esto es lo que viene siendo trabajar con bits.</p>"},{"location":"1_logica/04.logica/#operaciones-a-nivel-de-bit","title":"Operaciones a nivel de bit","text":"<p>Trabajar con n\u00fameros en su representaci\u00f3n binaria muchas veces es la forma m\u00e1s r\u00e1pida de hacer ciertas pruebas; dado que, de hecho, el n\u00famero ya est\u00e1 en esa representaci\u00f3n, hacer ciertas operaciones es m\u00e1s r\u00e1pido que hacerlo de otra forma. Por ejemplo, los n\u00fameros pasados a binario tienen un <code>1</code> como \u00faltimo bit si son impares, y <code>0</code> si son pares. Para comprobar si este \u00faltimo bit est\u00e1 encendido (o sea, es un 1), se compara bit a bit con <code>1</code></p> <pre><code>gore&gt; 33 &amp; 1\n1\ngore&gt; 30 &amp; 1\n0\n</code></pre> <p><code>&amp;</code> es el y bit a bit, o bitwise and, que toma cada bit de los dos operandos y lo compara, haciendo la operaci\u00f3n l\u00f3gica correspondiente y dando el resultado. De la misma forma se puede tambi\u00e9n multiplicar y dividir por 2 o cualquier potencia de 2, usando  los operadores que corren a la izquierda <code>&lt;&lt;</code> o derecha <code>&gt;&gt;</code> el n\u00famero de bits que le digamos.</p> <pre><code>gore&gt; 333 &gt;&gt; 1\n166\ngore&gt; 888 &lt;&lt; 1\n1776\n</code></pre> <p>As\u00ed, <code>&lt;&lt;</code> puede ser una forma r\u00e1pida de hallar potencias de 2</p> <pre><code>gore&gt; 2 &lt;&lt; 36\n137438953472\n</code></pre> <p>El siguiente operador es bastante interesante: <code>XOR</code>. Se trata de un operador l\u00f3gico que es 1 cuando uno de los dos operandos es 1, pero no cuando lo son los dos, se denomina o exclusivo o exclusive or. No existe un s\u00edmbolo en Go para representar este operando. Uno de sus usos es para hacer flipping, o cambiar el  valor de un bit a su contrario. Una forma r\u00e1pida de cambiar el bit n de un n\u00famero puede ser la siguiente:</p> <pre><code>gore&gt; 32 ^ (1 &lt;&lt; 3)\n40\n</code></pre> <p><code>1 &lt;&lt; 3</code> corresponder\u00eda al n\u00famero binario <code>100</code>, es decir, 1 corrido tres posiciones. 32 es el n\u00famero binario <code>10000</code>. <code>32 ^ 8</code> es <code>10000 ^ 100</code>, es decir, cambiar\u00eda el tercer bit (empezando por izquierda o derecha, da igual), que convertir\u00eda el n\u00famero en el 40 que vemos.</p> <p>En otros lenguajes, como Lua, se usan exactamente los mismos s\u00edmbolos para el mismo tipo de operadores. Estos operadores, al no ser naturales como la suma o la resta, se prestan a la creatividad por parte de los dise\u00f1adores de los lenguajes. Por ejemplo, en Lua hallar\u00edamos la media de 8 y 32 de esta forma:</p> <pre><code>&gt; (8+32) &gt;&gt; 1\n20\n</code></pre> <p>que, casualmente es exactamente la misma forma en la que lo har\u00edamos en Go o Python. El truco aqu\u00ed es simplemente darse cuenta de que <code>&gt;&gt; 1</code> es como una divisi\u00f3n entera por dos. Esto no funciona si alguno de los n\u00fameros es impar, pero si se trabaja s\u00f3lo con enteros ser\u00eda una forma muy r\u00e1pida, ya que se hace directamente en el procesador usando instrucciones del mismo, de realizar esta operaci\u00f3n.</p> <p>Ejercicio Implementar el operando <code>xor</code> utilizando los dem\u00e1s operadores l\u00f3gicos.</p> <p>Es muy probable que para alguno de los ejercicios anteriores hayas tenido buscar en Internet. Si lo has hecho, te habr\u00e1s dado cuenta de que</p>"},{"location":"1_logica/04.logica/#todo-esta-en-stackoverflow","title":"todo est\u00e1 en StackOverflow,","text":"<p>como ya hemos apuntado antes cuando hemos hablado de los problemas de entendimiento. </p> <p>Para qu\u00e9 vamos a enga\u00f1arnos, seguro que siguiendo este tutorial o, para el caso, cualquier otro, has consultado una o m\u00e1s veces Google buscando c\u00f3mo hacer algo. Un dominio ligero del ingl\u00e9s y una conexi\u00f3n a Internet es lo que hace falta para aprender pr\u00e1cticamente cualquier cosa, desde lenguajes a macram\u00e9. A un nivel en el que se est\u00e9 comenzando en un lenguaje, todas tus preguntas tendr\u00e1n cumplida respuesta, incluso si provienes de otro lenguaje de programaci\u00f3n preguntando equivalences of whatever thislanguage thisotherlanguage. En muchos casos habr\u00e1 tambi\u00e9n v\u00eddeos o cursos enteros, en ocasiones gratuitos, para aprender lo que uno desee.</p> <p>Muchas de las respuestas van a estar en StackOverflow, que se inici\u00f3 como un sitio de preguntas y respuestas pero que eventualmente ha evolucionado en una serie de sitios de diferentes temas, desde la historia hasta la estad\u00edstica pasando por LaTeX o, por supuesto, programaci\u00f3n.</p> <p>StackOverflow tiene un sistema de puntuaciones por parte de los usuarios que presenta como mejor respuesta la mejor puntuada; eso te garantiza, m\u00e1s o menos, que tu consulta va a obtener una buena respuesta, si es que la hay, ya que adem\u00e1s se pueden editar con el tiempo si quedan obsoletas por lo que sea. El \u00fanico peligro puede ser que la respuesta est\u00e9 obsoleta, pero de forma m\u00e1s o menos consistente sueles obtener una buena respuesta. A veces est\u00e1 en los foros de Reddit; Reddit tiene una serie de foros llamados subreddits donde se pueden postear preguntas y un sistema m\u00e1s o menos similar de puntuaci\u00f3n.</p> <p>Lo bueno que tienen estos sitios es precisamente esa interacci\u00f3n: puedes comenzar conversaciones y valorar las que hay. Si te das de alta puedes, y de hecho debes, votar a las preguntas que te ayuden, aparte de a las respuestas. Tambi\u00e9n editarlas si tienes karma suficiente, y por supuesto si en alguna puedes ayudar, aportar soluciones. Eventualmente, puedes tambi\u00e9n preguntar si tienes alguna duda, no sin antes hacer lo siguiente:</p> <ol> <li> <p>Buscar exhaustivamente por todo Google y el propio StackOverflow    por una respuesta a esa pregunta y algunas m\u00e1s generales.</p> </li> <li> <p>Reducir al m\u00ednimo trozo de c\u00f3digo el error o el problema que tengas. No puedes    subir 200 l\u00edneas de c\u00f3digo y esperar que alguien se las lea. Si el    error est\u00e1 en 2 l\u00edneas, mucho mejor.</p> </li> <li> <p>Poner de forma precisa cu\u00e1l es el error: mensaje de error completo    o de forma precisa qu\u00e9 es lo que quieres hacer y no puedes. Durante    este proceso el propio StackOverflow te sugerir\u00e1 otras    posibilidades. L\u00e9elas con cuidado, porque es posible que est\u00e9 la    respuesta.</p> </li> <li> <p>Una vez hecha la pregunta, dif\u00fandela por las redes sociales. Se    hacen miles de preguntas en StackOverflow a cada rato. Una puede pasar sin    pena, gloria ni soluci\u00f3n. La difusi\u00f3n ayuda.</p> </li> </ol> <p>Una vez que empieces a hacerlo, te convertir\u00e1s en un verdadero experto y comprender\u00e1s el chiste que circula diciendo que los cursos de programaci\u00f3n se van a renombrar \"Cortar y pegar de StackOverflow\". Lo cierto es que ayuda mucho desde el proceso de aprendizaje... Hasta el proceso de aprendizaje, que en programaci\u00f3n nunca acaba.</p>"},{"location":"1_logica/04.logica/#concluyendo","title":"Concluyendo","text":"<p>Los operadores l\u00f3gicos te ser\u00e1n necesarios a la hora de tomar decisiones sobre el flujo que tiene que seguir tu programa. Por otro lado, cuando vayas a enfrentarte a un problema, tienes que tomar algunas decisiones previas para tomar la mejor decisi\u00f3n posible. Por supuesto, es importante que aprendas a buscar informaci\u00f3n en Internet para resolver todos aquellos problemas ante los que te puedas encontrar mientras aprendes un lenguaje de programaci\u00f3n.</p>"},{"location":"2_doc_md/09.documentacion-con-markdown/","title":"Documentaci\u00f3n con Markdown","text":"<p>Un proyecto de programaci\u00f3n es tan \u00fatil como la documentaci\u00f3n que va con \u00e9l. Hay quien dice que una aplicaci\u00f3n es documentaci\u00f3n con un poco de c\u00f3digo a\u00f1adido.</p> <p>Como m\u00ednimo, necesitan un fichero <code>README.md</code> que explique la intenci\u00f3n del proyecto y qu\u00e9 hacer para instalarlo, as\u00ed como cualquier informaci\u00f3n adicional como quienes son los programadores y de qu\u00e9 van. Markdown, un lenguaje que permite a\u00f1adir marcas simples para indicar el papel de ciertas palabras en la estructura del documento, es una de las soluciones m\u00e1s universales.</p>"},{"location":"2_doc_md/09.documentacion-con-markdown/#por-que-markdown","title":"Por qu\u00e9 Markdown","text":"<p>Markdown es un lenguaje de marcado ligero que, una vez interpretado, permite dar formato a un  texto. Con este lenguaje, la meta es poder formatear de forma sencilla, donde la lectura sea clara y tener la posibilidad de convertir el resultado a otros formatos, como HTML o PDF.</p> <p>Cuando no est\u00e1 interpretado, es decir, es texto plano, ya proporciona bastante informaci\u00f3n. Es muy visual. Esto lo convierte en una herramienta genial para documentar nuestros programas, ya que en el c\u00f3digo fuente, en general, no tendremos ning\u00fan tipo de interpretaci\u00f3n de las marcas del lenguaje.</p> <p>Por otro lado, si utilizamos herramientas para generar documentaci\u00f3n a partir del c\u00f3digo fuente de nuestro programa, nos vemos obligados a aprender la sintaxis propia de esa herramienta, lo que se convierte en algo horrible teniendo en cuenta que cada lenguaje aporta su propio generador de documentaci\u00f3n de una forma m\u00e1s o menos est\u00e1ndar. Con Markdown podemos escribir siempre siguiendo el mismo formato y generar nuestra documentaci\u00f3n con las mismas herramientas, o similares, que las sugeridas en cada lenguaje; de hecho, Markdown se ha convertido en algo tan habitual que la mayor\u00eda de estas herramientas han incorporado alg\u00fan tipo de extensi\u00f3n para soportarlo.</p> <p>Tambi\u00e9n es muy \u00fatil para la generaci\u00f3n de p\u00e1ginas est\u00e1ticas creadas con software como Jekyll, o, como estamos utilizando Go, Hugo. Estas herramientas nos permiten completar enriquecer nuestra documentaci\u00f3n o crear un blog o una p\u00e1gina est\u00e1tica, yendo m\u00e1s all\u00e1 de la documentaci\u00f3n del propio c\u00f3digo.</p> <p>Pero es que el uso de Markdown expande sus horizontes m\u00e1s all\u00e1 del \u00e1mbito puramente relacionado con la programaci\u00f3n y desarrollo de software: redacci\u00f3n de art\u00edculos de investigaci\u00f3n, formateo de comentarios en sitios como reddit o el mismo StackOverflow mencionado anteriormente. Y tambi\u00e9n, por supuesto, para escribir libros como el que est\u00e1s leyendo ahora mismo son algunos de los usos que otra mucha gente da a este lenguaje.</p>"},{"location":"2_doc_md/09.documentacion-con-markdown/#enriqueciendo-documentos-con-markdown","title":"Enriqueciendo documentos con Markdown","text":"<p>Un documento, en general, va a tener un t\u00edtulo principal y luego una serie de secciones, con una jerarqu\u00eda inferior, que estructuran el texto en partes relacionadas. Un <code>README</code>, por ejemplo, tendr\u00e1, tras una introducci\u00f3n, instrucciones para instalar, para ejecutar y quiz\u00e1s una nota sobre la licencia o sobre c\u00f3mo colaborar con el mismo.</p> <p>Si quieres poner cabeceras a tu texto, algo as\u00ed como los t\u00edtulos de cada secci\u00f3n, solo tienes que escribir el car\u00e1cter almohadilla y un espacio antes de la frase a resaltar. Cuantas m\u00e1s almohadillas pongas, m\u00e1s abajo en la jerarqu\u00eda estar\u00e1 esa cabecera. Es decir, <code># Este es el nombre de mi proyecto</code> y <code>## C\u00f3mo instalar</code>. <code>### Instalar desde GitHub</code> y as\u00ed.</p> <p>Por ejemplo, si quieres tener tu texto en cursiva, solo necesitas abrir y cerrar la oraci\u00f3n con un asterisco, tal que <code>*este texto se muestra en cursiva*</code>. Tambi\u00e9n vale la barra baja \"<code>_</code>\" en lugar del asterisco. \u00bfQu\u00e9 tengo que hacer si quiero poner ese mismo texto en negrita? En lugar de utilizar un asterisco, utiliza dos. Tambi\u00e9n vale para el caso del car\u00e1cter \"barra baja\". Osea, <code>**este texto estar\u00eda en negrita**</code>. Y <code>**_este otro estar\u00eda en negrita y cursiva_**</code>.</p> <p>Markdown no interpretar\u00e1, al menos por defecto, cuando quieras incluir en tu texto un enlace a una p\u00e1gina web. Para incluir uno, tienes que hacerlo de la forma siguiente:<code>[Texto a mostrar](URL a la que ir)</code>. \u00bfAs\u00ed de f\u00e1cil? As\u00ed de f\u00e1cil.</p> <p>Insertar im\u00e1genes es muy parecido a insertar enlaces: la estructura es la misma, salvo que tenemos que poner un signo de admiraci\u00f3n justo antes del primer corchete. Osea, <code>![Texto a mostrar](URL a la imagen)</code>. En cuanto al \"texto a mostrar\", es el texto que ver\u00e1s si la imagen no carga o, si por ejemplo has exportado el documento a HTML, el texto que se muestra al poner el cursor del rat\u00f3n encima.</p> <p>\u00bfQu\u00e9 hay en un texto m\u00e1s enriquecedor que hacer referencia a otros textos o, incluso, a lo que simplemente alguien dijo en alg\u00fan momento? Para insertar una cita, solo necesitamos iniciar la cita con el car\u00e1cter \"mayor que\". Imagina que queremos citar a John Johnson, entonces: <code>&gt; \"Primero resuelve el problema. Entonces, escribe el c\u00f3digo\"</code>. Este texto se interpretar\u00e1 como:</p> <p>\"Primero resuelve el problema. Entonces, escribe el c\u00f3digo\"</p> <p>Las listas tampoco pod\u00edan faltar. Aqu\u00ed tenemos dos opciones: * Listas sin orden: para estas listas solamente necesitas poner cada elemento de la lista en una nueva l\u00ednea y preceder dicha l\u00ednea por un asterisco y un espacio. Un ejemplo de lista ser\u00eda: <pre><code>`* Resolver el problema`\n`* Escribir el c\u00f3digo`\n`* Compartir la soluci\u00f3n`\n</code></pre></p> <ul> <li>Listas ordenadas: tienes que precederlas por un n\u00famero seguido de un punto: <pre><code>`1. Resolver el problema`\n`2. Escribir el c\u00f3digo`\n`3. Compartir la soluci\u00f3n`\n</code></pre> Imagina que por alguna raz\u00f3n, no numeras bien la lista. \u00a1No pasa nada! El int\u00e9rprete se dar\u00e1 cuenta y mostrar\u00e1 correctamente la lista ordenada.</li> </ul> <p>\u00bfY qu\u00e9 pasa si quiero hacer una lista dentro de un elemento de una lista? Solamente tienes que a\u00f1adir un nivel de indentaci\u00f3n. Por ejemplo:</p> <pre><code>`* Resolver el problema`\n` * Mirar posibles soluciones`\n` * Establecer cual es la m\u00e1s adecuada`\n`* Escribir el c\u00f3digo`\n` * Elegir un lenguaje`\n` * Elegir los tipos de dato m\u00e1s adecuados`\n`* Compartir la soluci\u00f3n`\n` * Publicarla en Github`\n` * Escribir un art\u00edculo sobre ello`\n</code></pre> <p>Resultar\u00eda en: * Resolver el problema  * Mirar posibles soluciones  * Establecer cual es la m\u00e1s adecuada * Escribir el c\u00f3digo  * Elegir un lenguaje  * Elegir los tipos de dato m\u00e1s adecuados * Compartir la soluci\u00f3n  * Publicarla en Github  * Escribir un art\u00edculo sobre ello</p> <p>Con esta pincelada, tienes casi todo lo que hay que saber sobre Markdown. Pero Markdown es una base que tiene diferentes sabores. Algunos,  como el de GitHub, tienen algunas otras marcas que pueden ser muy \u00fatiles, como listas de tareas, tablas o resaltadores de sintaxis. Incluso emojis.</p>"},{"location":"2_doc_md/09.documentacion-con-markdown/#en-resumen","title":"En resumen","text":"<p>Markdown es un buen lenguaje para enriquecer el texto plano. Con unas pocas reglas de sintaxis puede hacer que tu texto incluya negritas, cursivas o cabeceras entre otros. Adem\u00e1s, es el lenguaje que se usa en webs como las que se alojan en Github. Pero ese ya es otro cap\u00edtulo.</p>"}]}